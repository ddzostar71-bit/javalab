# Лабораторная работа 1: Базовые алгоритмы и структуры данных

## Описание

Лабораторная работа включает 13 заданий на основы программирования на Java, охватывающие работу с циклами, условными операторами, массивами и матрицами.

## Задания

### Задание 1: Степени числа
**Описание:** Программа выводит первые четыре степени заданного числа n (n¹, n², n³, n⁴).

**Пример работы:**
```
Введите число n: 2
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
```

### Задание 2: Проверка пароля
**Описание:** Программа запрашивает пароль (4-значное число) до тех пор, пока он не будет правильно введен. Правильный пароль: `1234`.

**Пример работы:**
```
Введите пароль: 1111
Введите пароль: 5555
Введите пароль: 1234
Пароль верный! Доступ разрешен.
```

### Задание 3: Сумма n-значных чисел
**Описание:** Находит сумму всех n-значных чисел, где 1 ≤ n ≤ 4.

**Пример работы:**
```
Введите n (1-4): 2
Сумма 2-значных чисел: 4905
```

### Задание 4: Угадай число
**Описание:** Игра где программа загадывает случайное число от 1 до 10, а пользователь пытается его угадать с подсказками.

**Пример работы:**
```
Я загадал число от 1 до 10. Попробуйте угадать!
Ваш вариант: 5
Загаданное число больше
Ваш вариант: 8
Поздравляю! Вы угадали число 8
```

### Задание 5: Последовательность чисел
**Описание:** Выводит все четырехзначные числа последовательности 1000, 1003, 1006, 1009...

**Пример работы:**
```
Первые четырехзначные числа последовательности:
1000 1003 1006 1009 1012 1015 1018 1021 1024 1027
...
```

### Задание 6: Последовательность Фибоначчи
**Описание:** Выводит первые 11 членов последовательности Фибоначчи.

**Пример работы:**
```
Первые 11 членов Фибоначчи: 1 1 2 3 5 8 13 21 34 55 89
```

### Задание 7: Счастливые билеты
**Описание:** Подсчитывает количество "счастливых" билетов с номерами от 000001 до 999999. Счастливый билет - это билет, у которого сумма первых трех цифр равна сумме последних трех цифр.

**Примеры счастливых билетов:** 003102 (0+0+3 = 1+0+2), 567576 (5+6+7 = 5+7+6)

**Пример работы:**
```
Подсчет счастливых билетов...
Количество счастливых билетов в одном рулоне: 55252
```

### Задание 8: Проверка попадания в интервал
**Описание:** Проверяет, попадает ли случайное число из отрезка [5;155] в интервал (25;100).

**Пример работы:**
```
Случайное число: 67
Число 67 попадает в интервал (25;100)
```

### Задание 9: Конвертер секунд
**Описание:** Конвертирует секунды (от 0 до 28800) в часы с правильным склонением. Рабочий день составляет 8 часов (28800 секунд).

**Пример работы:**
```
Секунд осталось: 14400
осталось 4 часа
```

### Задание 10: Максимальный элемент массива
**Описание:** Создает массив из 12 случайных чисел от -15 до 15, находит максимальный элемент и индекс его последнего вхождения.

**Пример работы:**
```
Массив: 5 -3 12 8 -7 12 0 9 -15 12 3 -1
Максимальный элемент: 12
Индекс последнего вхождения: 9
```

### Задание 11: Массивы с четными элементами
**Описание:** Создает массив из n случайных чисел от 0 до n, затем формирует второй массив только из четных элементов первого.

**Пример работы:**
```
Введите натуральное число больше 3: 10
Первый массив: 3 8 2 7 0 5 4 9 1 6
Второй массив (четные): 8 2 0 4 6
```

### Задание 12: Примеры из таблицы умножения
**Описание:** Генерирует 15 уникальных примеров из таблицы умножения (от 2×2 до 9×9). Примеры 2×3 и 3×2 считаются одинаковыми.

**Пример работы:**
```
15 случайных примеров из таблицы умножения:
 1. 3 * 7 = ?
 2. 2 * 8 = ?
 3. 5 * 9 = ?
...
```

### Задание 13: Матрица с заменой элементов
**Описание:** В каждой строке матрицы находит минимальный и максимальный элементы. Меняет минимальный с последним элементом строки, а максимальный - с первым.

**Пример работы:**
```
Исходная матрица:
  45  78  12  90  34
  23  56  89  12  67
  ...

Матрица после преобразования:
  90  78  12  45  34
  89  56  12  23  67
  ...
```

## Запуск программы

### Компиляция
```bash
javac LaboratoryWork1.java
```

### Запуск
```bash
java LaboratoryWork1
```

### Интерактивное меню
После запуска программа выводит меню с выбором заданий:
```
Лабораторная работа 1 - Меню заданий:
1. Степени числа
2. Проверка пароля
3. Сумма n-значных чисел
4. Угадай число
5. Последовательность чисел
6. Последовательность Фибоначчи
7. Счастливые билеты
8. Проверка попадания в интервал
9. Конвертер секунд
10. Максимальный элемент массива
11. Массивы с четными элементами
12. Примеры из таблицы умножения
13. Матрица с заменой элементов

Выберите задание (1-13) или 0 для выхода:
```

## Требования
- Java 11 или выше
- Все задания выполняются в одной программе с интерактивным меню

## Структура кода
- Каждое задание реализовано в отдельном методе `taskN()` где N - номер задания
- Используются константы для улучшения читаемости кода
- Все методы документированы с помощью JavaDoc комментариев

---

## Техническая информация

### Используемые алгоритмы

#### Задание 1: Степени числа
**Алгоритм:** Итеративное возведение в степень
- **Сложность:** O(1) - фиксированное количество операций (4 итерации)
- **Метод:** Используется встроенный метод `Math.pow(base, exponent)`
- **Альтернатива:** Можно использовать последовательное умножение: `result *= n`

**Оптимизация:**
```java
// Менее эффективно (4 вызова Math.pow):
for (int i = 1; i <= 4; i++) {
    System.out.println(Math.pow(n, i));
}

// Более эффективно (последовательное умножение):
long result = n;
for (int i = 1; i <= 4; i++) {
    System.out.println(result);
    result *= n;
}
```

#### Задание 6: Последовательность Фибоначчи
**Алгоритм:** Итеративный метод Фибоначчи
- **Сложность:** O(n) по времени, O(1) по памяти
- **Преимущество:** Не использует рекурсию, избегая переполнения стека
- **Формула:** F(n) = F(n-1) + F(n-2), где F(0) = F(1) = 1

**Сравнение подходов:**
| Подход | Время | Память | Сложность кода |
|--------|-------|--------|----------------|
| Рекурсивный | O(2^n) | O(n) | Простой |
| Итеративный | O(n) | O(1) | Средний |
| Формула Бине | O(1) | O(1) | Сложный |

**Реализация:**
```java
int a = 1, b = 1;
for (int i = 0; i < 11; i++) {
    System.out.print(a + " ");
    int temp = a + b;
    a = b;
    b = temp;
}
```

#### Задание 7: Счастливые билеты
**Алгоритм:** Полный перебор с оптимизацией
- **Сложность:** O(n) где n = 1,000,000
- **Оптимизация:** Вместо проверки всех 6-значных чисел, проверяем только валидные комбинации сумм
- **Математика:** Количество способов получить сумму S из 3 цифр: комбинаторика с повторениями

**Анализ производительности:**
- Проверяется 999,999 билетов (от 000001 до 999999)
- Для каждого билета: 6 операций деления/остатка + 2 сложения + 1 сравнение
- Общее количество операций: ~9 миллионов
- Время выполнения: ~1-2 секунды на современном процессоре

**Альтернативный подход (комбинаторный):**
```java
// Подсчет через динамическое программирование
// Сложность: O(max_sum^2) ≈ O(27^2) = O(729) - намного быстрее!
int[] ways = new int[28];  // суммы от 0 до 27
// Заполняем массив количеством способов получить каждую сумму
```

#### Задание 13: Матрица с заменой элементов
**Алгоритм:** Линейный поиск минимума и максимума в строке
- **Сложность:** O(n*m) где n - строки, m - столбцы
- **Оптимизация:** Один проход по строке для поиска обоих элементов
- **Особенность:** Обработка случая когда min и max совпадают или находятся на граничных позициях

### Используемые Java API

#### java.util.Scanner
**Назначение:** Чтение пользовательского ввода
```java
Scanner scanner = new Scanner(System.in);
int number = scanner.nextInt();      // Чтение целого числа
String text = scanner.nextLine();    // Чтение строки
double value = scanner.nextDouble(); // Чтение вещественного числа
```

**Важные методы:**
- `nextInt()` - читает целое число, оставляет '\n' в буфере
- `nextLine()` - читает всю строку до '\n'
- `hasNext()` - проверяет наличие следующего токена
- `close()` - закрывает Scanner и освобождает ресурсы

**Распространенная ошибка:**
```java
int n = scanner.nextInt();      // Читает число, оставляет '\n'
String text = scanner.nextLine(); // Читает пустую строку!

// Правильно:
int n = scanner.nextInt();
scanner.nextLine();  // Очистить буфер
String text = scanner.nextLine();
```

#### java.util.Random
**Назначение:** Генерация псевдослучайных чисел
```java
Random random = new Random();
int value = random.nextInt(151) + 5;  // [5, 155]
```

**Методы:**
- `nextInt(bound)` - случайное число от 0 до bound-1
- `nextDouble()` - случайное число от 0.0 до 1.0
- `nextBoolean()` - случайный boolean
- `setSeed(long seed)` - устанавливает seed для воспроизводимости

**Диапазон [min, max]:**
```java
int result = random.nextInt(max - min + 1) + min;
// Пример: [5, 155] → nextInt(151) + 5
```

### Работа с массивами

#### Создание и инициализация
```java
// Фиксированный размер
int[] array = new int[10];

// Инициализация значениями
int[] array = {1, 2, 3, 4, 5};

// Заполнение случайными числами
for (int i = 0; i < array.length; i++) {
    array[i] = random.nextInt(31) - 15;  // от -15 до 15
}
```

#### Поиск максимума/минимума
**Алгоритм:**
```java
int max = array[0];
int maxIndex = 0;
for (int i = 1; i < array.length; i++) {
    if (array[i] >= max) {  // >= для последнего вхождения
        max = array[i];
        maxIndex = i;
    }
}
```

**Сложность:** O(n) - один проход

#### Фильтрация массива
```java
// Задание 11: выбор четных элементов
// Подход 1: Два прохода (используется в коде)
int count = 0;
for (int num : array) {
    if (num % 2 == 0) count++;
}
int[] evenArray = new int[count];
// ... заполнение

// Подход 2: ArrayList (более гибко)
ArrayList<Integer> evenList = new ArrayList<>();
for (int num : array) {
    if (num % 2 == 0) evenList.add(num);
}
```

### Работа с матрицами

#### Представление в памяти
```java
int[][] matrix = new int[rows][cols];
// Хранится как массив массивов:
// matrix[0] → [первая строка]
// matrix[1] → [вторая строка]
```

#### Обход матрицы
```java
// По строкам (быстрее из-за локальности кэша)
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        process(matrix[i][j]);
    }
}

// По столбцам (медленнее)
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        process(matrix[i][j]);
    }
}
```

### Анализ сложности по заданиям

| Задание | Временная сложность | Пространственная сложность | Примечания |
|---------|---------------------|----------------------------|------------|
| 1 | O(1) | O(1) | Фиксированное число операций |
| 2 | O(n) | O(1) | n - количество попыток ввода |
| 3 | O(10^n) | O(1) | n - количество цифр (1-4) |
| 4 | O(n) | O(1) | n - количество попыток |
| 5 | O(n) | O(1) | n - количество элементов последовательности |
| 6 | O(n) | O(1) | n = 11 элементов Фибоначчи |
| 7 | O(n) | O(1) | n = 1,000,000 билетов |
| 8 | O(1) | O(1) | Одна генерация и проверка |
| 9 | O(1) | O(1) | Арифметические операции |
| 10 | O(n) | O(n) | n = 12 элементов массива |
| 11 | O(n) | O(n) | n - размер массива |
| 12 | O(n) | O(n) | n = 15, требует Set для уникальности |
| 13 | O(n*m) | O(n*m) | n×m матрица |

### Лучшие практики и рекомендации

#### 1. Использование констант
```java
// Плохо: магические числа
if (password == 1234) { ... }

// Хорошо: именованные константы
private static final int CORRECT_PASSWORD = 1234;
if (password == CORRECT_PASSWORD) { ... }
```

#### 2. Проверка граничных случаев
```java
// Задание 3: проверка диапазона
if (n < 1 || n > 4) {
    System.out.println("Ошибка: n должно быть от 1 до 4");
    return;
}
```

#### 3. Избегание переполнения
```java
// Задание 3: сумма может превысить int
long sum = 0;  // Используем long вместо int
for (int i = start; i <= end; i++) {
    sum += i;
}
```

#### 4. Правильное склонение
```java
// Задание 9: русское склонение "час/часа/часов"
String hourWord;
if (hours % 10 == 1 && hours % 100 != 11) {
    hourWord = "час";
} else if (hours % 10 >= 2 && hours % 10 <= 4 &&
           (hours % 100 < 10 || hours % 100 >= 20)) {
    hourWord = "часа";
} else {
    hourWord = "часов";
}
```

### Распространенные ошибки

#### 1. Ошибка fence-post (забор)
```java
// Ошибка: пропускаем последний элемент
for (int i = 0; i < array.length - 1; i++) { }  // ❌

// Правильно
for (int i = 0; i < array.length; i++) { }       // ✅
```

#### 2. Целочисленное деление
```java
int a = 5, b = 2;
int result = a / b;        // 2 (обрезается)
double result = a / b;     // 2.0 (деление выполнилось как int)
double result = (double)a / b;  // 2.5 ✅
```

#### 3. Сравнение вещественных чисел
```java
double a = 0.1 + 0.2;
if (a == 0.3) { }  // ❌ Может быть false из-за погрешности

// Правильно: используем epsilon
final double EPSILON = 1e-9;
if (Math.abs(a - 0.3) < EPSILON) { }  // ✅
```

### Оптимизация производительности

#### 1. Локальность данных
Обращение к последовательным элементам массива быстрее благодаря CPU cache:
```java
// Быстрее (последовательный доступ)
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        sum += matrix[i][j];
    }
}
```

#### 2. Избегание создания объектов в циклах
```java
// Медленно
for (int i = 0; i < 1000000; i++) {
    String s = new String("test");  // 1М объектов
}

// Быстро
String s = "test";  // Один объект
for (int i = 0; i < 1000000; i++) {
    process(s);
}
```

#### 3. StringBuilder для конкатенации в циклах
```java
// Медленно: O(n²) из-за immutable String
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // Создается новый String каждый раз
}

// Быстро: O(n)
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

### Математические концепции

#### Арифметическая прогрессия
**Задание 3:** Сумма n-значных чисел
```
Формула суммы: S = (first + last) * count / 2
Для 2-значных: S = (10 + 99) * 90 / 2 = 4905
```

#### Проверка четности
```java
// Способ 1: остаток от деления
if (n % 2 == 0) { }

// Способ 2: побитовое И (быстрее)
if ((n & 1) == 0) { }
```

#### Поиск последнего вхождения
```java
// Используем >= вместо >
if (array[i] >= max) {  // >= обновляет при равенстве
    max = array[i];
    maxIndex = i;
}
```

## Автор
Student

## Версия
2.0
